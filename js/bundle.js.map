{"version":3,"file":"bundle.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,+BAA+B;AAC/B,4CAA4C;AAC5C,qEAAqE;AACrE,6CAA6C;AAC7C;AACA,+EAA+E;AAC/E,6CAA6C;AAC7C;AACA,KAAK;AACL;AACA;AACA,qEAAqE;AACrE,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,0DAA0D;AAC1D,sBAAsB,gBAAgB;AACtC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,8DAA8D;AAC9D;AACA;AACA,cAAc;AACd,mDAAmD;AACnD;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA,sCAAsC;AACtC,oDAAoD;AACpD,aAAa;AACb,iDAAiD;AACjD,yBAAyB;AACzB,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE,gCAAgC;AAChC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU,MAAM,SAAS;AAC5D,0DAA0D,WAAW;AACrE,wDAAwD,WAAW;AACnE;AACA;AACA;AACA,kEAAkE,WAAW;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,IAAI,YAAY,WAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iCAAiC;AAC5D;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA,oBAAoB;AACpB,gBAAgB;AAChB;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,eAAe;AACf,0CAA0C;AAC1C,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,+CAA+C;AAC/C,aAAa;AACb;AACA;AACA,8BAA8B;AAC9B,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,iCAAiC;AACjC;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,sBAAsB;AACtB;AACA,KAAK;AACL;AACA;AACA,6BAA6B;AAC7B;AACA,sBAAsB;AACtB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E,+CAA+C;AAC/C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,+CAA+C;AAC/C,kDAAkD;AAClD,sBAAsB;AACtB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,wBAAwB;AACxB,mBAAmB;AACnB;AACA;AACA;AACA,4BAA4B,cAAc,GAAG;AAC7C,8BAA8B,WAAW,IAAI;AAC7C;AACA;AACA,MAAM,mCAAmC;AACzC,yCAAyC;AACzC;AACA;AACA,qDAAqD;AACrD,oCAAoC;AACpC;AACA,yCAAyC;AACzC;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,CAAC;AACD;AACA,qCAAqC;AACrC;AACA,qBAAqB;AACrB,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,eAAe,mBAAmB,KAAK;AACvC,8CAA8C;AAC9C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,mDAAmD;AACnD,2BAA2B;AAC3B;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,mDAAmD;AACnD,2BAA2B;AAC3B;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,uCAAuC;AACvC,wEAAwE,0HAA0H,0HAA0H,0HAA0H;AACtb;AACA,6BAA6B;AAC7B;AACA,uDAAuD;AACvD,+BAA+B;AAC/B;AACA,KAAK;AACL,CAAC;AACD;AACA,yBAAyB;AACzB,oDAAoD;AACpD,yCAAyC;AACzC;AACA;AACA,gCAAgC;AAChC,iDAAiD,SAAS,MAAM;AAChE;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK,GAAG;AAC1C;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;ACpCA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,IAAI,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UCvEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;ACtBA;AACA,mBAAmB,mBAAO,CAAC,4CAAgB;AAC3C,mBAAmB,mBAAO,CAAC,4CAAgB;AAC3C,oBAAoB,mBAAO,CAAC,8CAAiB;AAC7C,oBAAoB,mBAAO,CAAC,8CAAiB;AAC7C,oBAAoB,mBAAO,CAAC,8CAAiB;AAC7C,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,oBAAoB,mBAAO,CAAC,8CAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA","sources":["webpack://food/./js/modules/calc.js","webpack://food/./js/modules/cards.js","webpack://food/./js/modules/forms.js","webpack://food/./js/modules/modal.js","webpack://food/./js/modules/slider.js","webpack://food/./js/modules/tabs.js","webpack://food/./js/modules/timer.js","webpack://food/webpack/bootstrap","webpack://food/./js/script.js"],"sourcesContent":["﻿function calc(){\r\n// * * * * * * * * \r\n// К А Л Ь К У Л Я Т О Р \r\nconst result = document.querySelector('.calculating__result span'); //получаем место где будет записан результат\r\n\r\n\r\n//переменные для хранения данных - пока без дефолтных значений\r\nlet sex, height, weight, age, ratio; //\r\n\r\n //добавляем проверку - есть ли данные по умолчанию sex в localStorage и если есть - устанавливаем их по дефолту\r\nif(localStorage.getItem('sex')){\r\n    sex = localStorage.getItem('sex');\r\n} else {\r\n    //вручную задаем дефолтные значения\r\n    sex = 'female';\r\n    localStorage.setItem('sex', 'female');  //и устанавливаем дефолтное значение\r\n};\r\n //добавляем проверку - есть ли данные по умолчанию ratio в localStorage и если есть - устанавливаем их по дефолту\r\n if(localStorage.getItem('ratio')){\r\n    ratio = localStorage.getItem('ratio');\r\n} else {\r\n    //вручную задаем дефолтные значения\r\n    ratio = '1.375';\r\n    localStorage.setItem('ratio', '1.375');  //и устанавливаем дефолтное значение\r\n};\r\n//функция для задания класса активности дефолтным элементам\r\nfunction initLocalSettings(selector, activeClass){\r\n    //\r\n    const elements = document.querySelectorAll(selector); //поиск элементов\r\n    elements.forEach(elem => { //перебираем элементы\r\n        elem.classList.remove(activeClass); //убираем класс активности у всех элементов\r\n        if(elem.getAttribute('id') === localStorage.getItem('sex')){ //и если элемент c определенным id строго равен значению из localStorage \r\n            elem.classList.add(activeClass); //то этому диву мы добавляем класс активности\r\n        }\r\n        if(elem.getAttribute('data-ratio') === localStorage.getItem('ratio')){ //если элемент с определенным атрибутом строго равен значению из localStorage \r\n            elem.classList.add(activeClass); //добавляем класс активности\r\n        }\r\n    });\r\n}\r\n                            \r\ninitLocalSettings('#gender div', 'calculating__choose-item_active'); //вызов по селектору + div по id\r\ninitLocalSettings('.calculating__choose_big div', 'calculating__choose-item_active'); //вызов по селектору + div  по data-ratio\r\n  \r\n\r\n\r\nfunction calcTotal(){\r\n    //проверка введенных данных - если хотябы одного из этих значений нет\r\n    if(!sex || !height || !weight || !age || !ratio){\r\n        result.textContent =\"мало данных\";\r\n        return; //выход из калькулятора\r\n    }\r\n    //если данные есть - \r\n    //расчет для женщин и мужчин\r\n    if(sex === 'female'){\r\n        result.textContent = Math.round((447.6 + (9.2 *  weight) + (3.1 * height) - (4.3 * age)) * ratio);\r\n    } else{\r\n        result.textContent =  Math.round((88.36 + (13.4 *  weight) + (4.8 * height) - (5.7 * age)) * ratio);\r\n    }\r\n\r\n}\r\n\r\n calcTotal();  //\r\n//получение данных элементов\r\nfunction getStaticInformation(selector, activeClass){\r\n    //получаем элементы внутри родительского блока - \r\n    const elements = document.querySelectorAll(selector); //ищем по селектору элементы\r\n    // console.log(`${parentSelector} div`);\r\n    console.log('calcTotal elements'); console.log(elements);\r\n//перебираем элементы //раньше было делегирование событий - но ему мешало межблоковые промежутки\r\n    elements.forEach(elem =>{\r\n        elem.addEventListener('click', (e) =>{\r\n            //если у блока есть атрибут data-ratio - то берем его значение, если такого атрибута нет - берем id\r\n            //e.target - объект события \r\n            if(e.target.getAttribute('data-ratio')){ //если атрибут есть\r\n                ratio = +e.target.getAttribute('data-ratio'); //мы получаем его значение\r\n                //записываем данные в localStorage = ключ ratio, значение - выбранное поле +e.target.getAttribute('data-ratio')\r\n                localStorage.setItem('ratio', +e.target.getAttribute('data-ratio'));\r\n            } else {\r\n                sex = e.target.getAttribute('id'); //если нет атрибута берем id \r\n                //записываем данные в localStorage = ключ sex, значение - выбранное поле e.target.getAttribute('id')\r\n                localStorage.setItem('sex', e.target.getAttribute('id')); \r\n            }\r\n            \r\n            console.log(ratio, sex, height, weight, age); //для проверки\r\n            //работа с классами активности\r\n            elements.forEach(elem =>{ //сначала перебираем все \r\n                elem.classList.remove(activeClass); //и удаляем у всех элементов класс активности\r\n            });\r\n            e.target.classList.add(activeClass); //добавляем класс активности объекту событий\r\n            calcTotal(); //вызов главной функции для пересчета\r\n        });\r\n        \r\n    });\r\n}\r\n//вызов метода выбора с 2ми разными (строка 1 и строка 3) селекторами и div!!!\r\ngetStaticInformation('#gender div', 'calculating__choose-item_active');\r\ngetStaticInformation('.calculating__choose_big div', 'calculating__choose-item_active');\r\n\r\n//функция по получению данных с инпута\r\nfunction getDinamucInformation(selector){\r\n    const input = document.querySelector(selector); //получаем инпут\r\n    //событие ввода данных\r\n    input.addEventListener('input', () =>{\r\n        //проверка на корректность данных\r\n        if(input.value.match(/\\D/g)){\r\n            input.style.border = '1px solid red';\r\n        }\r\n        else{\r\n            input.style.border = 'none';\r\n        }\r\n        //надо сделать проверку - какому атрибуту соответствует инпут, такое значение и присвоить.\r\n        switch(input.getAttribute('id')){\r\n            case 'height':\r\n                height = +input.value;\r\n                break;\r\n            case 'weight' :\r\n                weight = +input.value;\r\n                break;\r\n            case 'age' :\r\n                age = +input.value;\r\n                break;\r\n        }\r\n        calcTotal(); //вызов главной функции для прересчета\r\n    });\r\n    \r\n}\r\n// вызываем функцию с тремя разными селекторами\r\n\r\ngetDinamucInformation('#height');\r\ngetDinamucInformation('#weight');\r\ngetDinamucInformation('#age');\r\n\r\n\r\n}\r\nmodule.exports = calc; ","﻿function cards(){\r\n    // ******************************************\r\n    // КЛАССЫ ДЛЯ КАРТОЧЕК\r\n    class MenuCard {\r\n        constructor(src, alt, title, descr, price, parentSelector){\r\n            //картинка\r\n            this.src = src;\r\n            this.alt= alt;\r\n            this.title  = title;\r\n            this.descr = descr;\r\n            this.price = price;\r\n            this.parent = document.querySelector(parentSelector); //тут именно родитель!\r\n            this.transfer = 10; //тут пока статическое число\\\r\n            this.changeToYuan(); //вызов нашего новосозданного метода\r\n        }\r\n        changeToYuan(){\r\n            return this.price = this.transfer * this.price;\r\n        }\r\n        //метод render - формируетверстку\r\n        render(){\r\n            const element = document.createElement('div');\r\n            element.innerHTML =`\r\n                    <div class=\"menu__item\">\r\n                        <img src=${this.src} alt=${this.alt}>\r\n                        <h3 class=\"menu__item-subtitle\">${this.title}</h3>\r\n                        <div class=\"menu__item-descr\">${this.descr}</div>\r\n                        <div class=\"menu__item-divider\"></div>\r\n                        <div class=\"menu__item-price\">\r\n                            <div class=\"menu__item-cost\">Цена:</div>\r\n                            <div class=\"menu__item-total\"><span>${this.price}</span> руб/день</div>\r\n                        </div>\r\n                    </div>       \r\n            `;\r\n            //добавляем в конец\r\n            this.parent.append(element);\r\n        }\r\n    }\r\n    //функция получения данных для карточек с сервера\r\n    const getResource = async (url) =>{\r\n        // мы делаем запрос по url\r\n        const res = await fetch(url);\r\n        if(!res.ok){\r\n            //добавим объект ошибки \r\n            // Если мы выбрасываем ошибку в ручном режиме, у нас срабатывает блок кода catch()\r\n            throw new Error(`Could not fetch ${url}, status: ${res.status}`);\r\n        }\r\n       //дожидаемся его окончания и ттрансформируем  его в объект\r\n        return await res.json();\r\n    };\r\n    //ЭТО РАБОЧАЯ ВЕРСИЯ генерации карточек !!!\r\n    // вызов функции геренации карточек из bd.json на основе класса\r\n    getResource('http://localhost:3000/menu')\r\n        .then(data =>{\r\n            data.forEach(({img, alting, title, descr, price}) =>{\r\n                new MenuCard(img, alting, title, descr, price, '.menu .container').render();\r\n            });\r\n        });\r\n\r\n}\r\n// //*** БИБЛИОТЕКА Axios\r\n//     //переменная axios идет из подключенной библиотеки\r\n//     axios.get('http://localhost:3000/menu')\r\n    \r\n//      .then(data => {\r\n//         //data.data. -потому что мы обращаемся к тем данным, которые получили, а не к общему объекту \r\n//         data.data.forEach(({img, alting, title, descr, price}) =>{\r\n//                     new MenuCard(img, alting, title, descr, price, '.menu .container').render();\r\n//                 });\r\n//             });\r\nmodule.exports = cards;","function forms(){\r\n\r\n    //053\r\n    //forms   - ответы JS_step_13\r\n    const forms = document.querySelectorAll('form'); //ищем все формы по тегу form \r\n    //message ответы\r\n    const message = {\r\n        loading: 'img/form/spinner.svg',\r\n        success: 'Спасибо! мы скоро с вами свяжемся',\r\n        fail: 'что-то пошло не так'\r\n    };\r\n    //для каждой forms вызываем функцию postData()\r\n    forms.forEach(item =>{\r\n        bindpostData(item);\r\n    });\r\n\r\n    //Функция для работы с сервером\r\n    //создадим переменную - postData, отвечающую за отправку данных\r\n    //а в ней агрументы - url - для fetch, и data - данные, которые будут поститься\r\n    //async - означает, что внутри функции у нас будет асинхронный код \r\n    const postData = async (url, data) =>{\r\n        //в переменную res помещаем возвращенный fetch/чем промиc \r\n        //настраиваем \r\n        //парный оператор await - ставиться перед теми операциями, которые необходимо дождаться\r\n        const res = await fetch(url, {\r\n            method: \"POST\",\r\n            headers: {\r\n                //все будем постит в формате json (тк json-сервер)\r\n                'Content-type': 'application/json'\r\n            },\r\n            //data - данные, которые будут поститься\r\n            body: data\r\n        } );\r\n        //из ф-ции возвращаем res в json формате\r\n        //тут await чтобы получить json из промиса и только потом возратить его из функции\r\n        return await res.json();\r\n    };\r\n\r\n\r\n    \r\n    //функция постинга данных - bindpostDate с параметром form - для дальнейшей привязки к обработчику событий\r\n    function bindpostData(form){\r\n        //событие submit срабатывает когда мы пытаемся отправить запол форму. \r\n        //Есть встроенное поведение кнопки формы с типом submit - с перезагрузкой страницы, но мы отключим его для своей программы действий\r\n        form.addEventListener('submit', (e)=>{\r\n            e.preventDefault(); //отмена перезагрузки страницы\r\n            //динамически создаем элемент для сообщения о работе ссистемы\r\n            const statusMessage = document.createElement('img');\r\n            statusMessage.src = message.loading; //или можно установить через  setAttribute\r\n            statusMessage.style.cssText =`\r\n                display: block;\r\n                margin: auto;\r\n            `; //стили для спиннера\r\n            //form.append(statusMessage); //добавляем на страницу\r\n            form.insertAdjacentElement('afterend', statusMessage); //добавляем на страницу ПОСЛЕ формы\r\n            //***\r\n           \r\n            \r\n            \r\n       \r\n            //создадим экземпляр объекта formData от параметра form\r\n            const formData = new FormData(form);\r\n            //для преобразования объекта formData в JSON методом entries и fromEntries\r\n            //entries позволит получить данные формы в формате массивов\r\n            //fromEntries - из массива в классический объект\r\n            const json = JSON.stringify(Object.fromEntries(formData.entries())); \r\n           \r\n              //вызов функции постинга\r\n            postData('http://localhost:3000/requests', json)\r\n            //блок успешного выполнения\r\n                .then(data => {\r\n                //data - данные, которые вернулись из промиса\r\n                console.log(data);\r\n                showThanksModal(message.success); //'Спасибо! мы скоро с вами свяжемся'\r\n                \r\n                statusMessage.remove();\r\n                         // удаляем сообщение  statusMessage \r\n            })\r\n            //блок обработки ошибок\r\n            .catch(()=>{\r\n                showThanksModal(message.fail); //’что-то пошло не так’\r\n            })\r\n            //блок \r\n            .finally(()=>{\r\n                form.reset(); //спец метод формы очищающий ее\r\n            });\r\n//\r\n           \r\n        });\r\n    }\r\n//end 053\r\n\r\n}\r\n\r\nmodule.exports = forms; ","﻿function modal(){\r\n// модальное окно\r\n \r\nconst modalTrigger = document.querySelectorAll('[data-modal]'), // кнопки вызывающие модальное окно\r\nmodal = document.querySelector('.modal'); //само модальное окно\r\n//modalCloseBtn = document.querySelector('[data-close]'); //кнопка закрытия модального окна УДАЛИЛИ для делегирования\r\n \r\n\r\nfunction openModal(){\r\n    modal.classList.add('show');\r\n    modal.classList.remove('hide');\r\n    document.body.style.overflow = 'hidden'; //фиксируем страницу\r\n}\r\n\r\n//открытие модального окна\r\nmodalTrigger.forEach(btn=>{\r\nbtn.addEventListener('click', openModal);\r\n});\r\n//функция для вызова модального окна черезопределенный момент времени\r\n\r\n\r\n\r\n\r\nfunction closeModal(){\r\n    modal.classList.add('hide');\r\n    modal.classList.remove('show');\r\n    document.body.style.overflow = ''; //разрешает скроллить страницу вновь\r\n    clearInterval(modalTimerId); //очистит таймер при  открытии модального окна\r\n}\r\n\r\n//закрытие модального окна\r\n// modalCloseBtn.addEventListener('click', closeModal); //!! функцию тут не вызвваем ,а просто передаем УДАЛИЛИ для делегирования\r\n   \r\nmodal.addEventListener('click', (e)=>{\r\n    if(e.target === modal || e.target.getAttribute('data-close')==\"\"){\r\n        closeModal(); //\r\n     }\r\n    });\r\n\r\ndocument.addEventListener('keydown', (e)=>{\r\n    if(e.code ==='Escape'){  //e.code ==='Escape'  - проверяем кнопку, проверяем открыто ли окно - оно открыто если содержит класс show \r\n        // && modal.classList.contains('show')\r\n        closeModal(); //\r\n    }\r\n\r\n});\r\n\r\n//функция для вызова модального окна через ... секунд\r\n// \r\nconst modalTimerId = setTimeout(openModal, 50000);\r\n\r\nfunction showModalByScroll(){\r\n    //window.pageYOffset  - прокрученная часть \r\n        // + document.documentElement.clientHeight  - видимая часть экрана в данный момент без прокрутки\r\n        // >=document.documentElement.scrollHeight - высота скорлла\r\n    \r\n    if(window.pageYOffset + document.documentElement.clientHeight >=document.documentElement.scrollHeight){\r\n        openModal(); //первый раз показываем модальное окно\r\n        window.removeEventListener('scroll', showModalByScroll); //удаляем обработчик событий\r\n    }\r\n}\r\n\r\n\r\n    window.addEventListener('scroll', showModalByScroll);\r\n    //функция модального окна \"Спасибо\"\r\n    function showThanksModal(message){\r\n        const prevModalDialog = document.querySelector('.modal__dialog'); //находим модальное окно (с текстом)\r\n        prevModalDialog.classList.add('hide'); //скрываем окно имеющимся классом \r\n        //теперь открываем пустой блок модального окна \r\n        openModal(); //ф-ция открытия модального окна\r\n        //создание контента модального окна спасибо\r\n        const thanksModal = document.createElement('div'); \r\n        thanksModal.classList.add('modal__dialog');\r\n        //div class=\"modal__content\" - класс обертка, ✖ - для закрытия, modal-title - заголовок, в которые мы должны поместить состояние загрузки\r\n        //с ✖ созданный динамически не будет реагировать на те действия, которые были созданны для него ранее\r\n        thanksModal.innerHTML = `\r\n            <div class=\"modal__content\">\r\n                <div class='modal__close' data-close>✖</div>\r\n                <div class='modal__title'>${message}</div>\r\n        </div>\r\n        `;\r\n        //получаем модальное окно и добавл на страницу\r\n        document.querySelector('.modal').append(thanksModal);\r\n        //удаляем окно-спасибо через 4с\r\n        setTimeout(()=>{thanksModal.remove();\r\n        prevModalDialog.classList.add('show'); //показываем модальное окно\r\n        prevModalDialog.classList.remove('hide'); //удаляем класс сокрытия модальное окно\r\n        closeModal(); //и закрываем модальное окно\r\n        },  4000);\r\n    }\r\n\r\n    fetch('http://localhost:3000/menu')\r\n        .then(data => data.json())\r\n        .then(res => console.log(res));\r\n\r\n\r\n\r\n\r\n\r\n}\r\nmodule.exports = modal; ","﻿function slider(){\r\n// **********************************\r\n//           СЛАЙДЕР №2 -карусель\r\n\r\nconst   slides = document.querySelectorAll('.offer__slide'),    //количество слайдов\r\n        slider = document.querySelector('.offer__slider'),      //весь слайд - с индикаторами и слайдами\r\n        prev = document.querySelector('.offer__slider-prev'),   //кнопка пред\r\n        next = document.querySelector('.offer__slider-next'),   //кнопка следующий\r\n        total= document.querySelector('#total'),                // общее кол-во слайдов      \r\n        current = document.querySelector('#current'),           //индекс текущего слайда\r\n        slidesWrapper = document.querySelector('.offer__slider-wrapper'), //главная обертка\r\n        slidesField = document.querySelector('.offer__slider-inner'),     //обертка слайдов\r\n\r\n        //переменная будет хранить шрину внешнего блока .offer__slider-wrapper,  .match(/\\d/g) - возвращает массив чисел, join('') - объединяет числа \r\n        // width = +(window.getComputedStyle(slidesWrapper).width).match(/\\d/g).join('');  \r\n        width = +(window.getComputedStyle(slidesWrapper).width).replace(/\\D/g, '');  \r\n        //!!!регулярными выражениями можно было бы еще сделать замену всех НЕ чисел на пустоту\r\n        //width.replace(/\\D/g, ''); - такое выражение вернет сразу число\r\n\r\n   \r\n\r\n//  \r\n   let slideIndex = 1;  //для цифры №слайда в окошке\r\n   let offset = 0; //считает отступ вправо или лево\r\n   //НАЧАЛЬНАЯ ИНИЦИАЛИЗАЦИЯ\r\n   //Номера слайдов для подстановки на страницу - \r\n   if(slides.length < 0){\r\n    total.textContent = `0${slides.length}`; //итого слайдов\r\n    current.textContent = `0${slideIndex}`;  //текущий\r\n}\r\n//если больше 10 то оставляем так\r\nelse{ total.textContent = slides.length; //итого слайдов\r\n    current.textContent = slideIndex;    //текущий\r\n}\r\n\r\nslidesField.style.width = 100 * slides.length + '%'; //установим блоку ширину, знак % - для css\r\nslidesField.style.display = 'flex'; //выравниваем все слайды по горизонтали\r\nslidesField.style.transition = '0.5s all';  \r\nslidesWrapper.style.overflow = 'hidden'; //скрываем все \"торчащие\" из окна слайды\r\n\r\nslides.forEach(slide =>{\r\n    slide.style.width = width; //устанавливаем каждому слайду одинаковую ширину\r\n    \r\n\r\n});\r\n//доработка ДЛЯ точек\r\nslider.style.position = 'relative';  //установка для всего слайда позиции\r\nconst   indicators = document.createElement('ol'), //создаем обертку для точек\r\n        dots  = [];  //создаем массив для точек (которые создадим далее)\r\nindicators.classList.add('carusel-indicator');  //создаем класс\r\n//создаем динамически стили классу carusel-indicator\r\nindicators.style.cssText = `\r\n    position: absolute;\r\n    right: 0;\r\n    bottom: 0;\r\n    left: 0;\r\n    z-index: 15;\r\n    display: flex;\r\n    justify-content: center;\r\n    margin-right: 15%;\r\n    margin-left: 15%;\r\n    list-style: none;\r\n`\r\nslider.append(indicators); //добавляем на страницу\r\n//в цикле создаем точку, атрибут и \r\nfor(let i = 0; i < slides.length; i++){//перебираем все точки \r\n    const dot = document.createElement('li'); //создаем элемент\r\n    dot.setAttribute('data-slide-to', i+1); //добавляем ему атрибут с уникальным номером\r\n    dot.style.cssText  =`\r\n        box-sizing: content-box;\r\n        flex: 0 1 auto;\r\n        width: 30px;\r\n        height: 6px;\r\n        margin-right: 3px;\r\n        margin-left: 3px;\r\n        cursor: pointer;\r\n        background-color: #fff;\r\n        background-clip: padding-box;\r\n        border-top: 10px solid transparent;\r\n        border-bottom: 10px solid transparent;\r\n        opacity: .5;\r\n        transition: opacity .6s ease;\r\n    `\r\n    if(i == 0){\r\n        dot.style.opacity = 1;\r\n    }\r\n    indicators.append(dot);\r\n    dots.push(dot);   //пушим точки в массив\r\n}\r\n\r\n\r\n\r\n\r\n\r\n//нажали на кнопку назад\r\nnext.addEventListener('click', ()=>{\r\n    //предусматриваем конечный вариант - когда дошли до края - возврашаем слайдер в начаьное положение\r\n    // +width.slice(0, width.length - 2)  - плюс перед width меняет формат на числовой, а метод slice вырезает все нужное - с 0-вого элемента до длина width - 2 последних символа.\r\n   \r\n    if(offset == width * (slides.length -1)){\r\n        offset = 0;\r\n    }\r\n    else{\r\n        offset += width;\r\n    }\r\n\r\n\r\n    \r\n    caruselMove(offset); //смещаем карусель слайдов\r\n   \r\n    //меняем индекс слайда\r\n\r\n\r\n    if(slideIndex == slides.length){ //если мы дошли до конца - то иди в слайд номер 1\r\n        slideIndex = 1;\r\n    }\r\n    else{\r\n        slideIndex++; //или +1 слайд\r\n    }\r\n    \r\n    \r\n\r\n    currentSl(slides.length, current, slideIndex); // изменение текущего индикатора\r\n    dotActive(slideIndex); //выделение активной точки\r\n   \r\n});\r\n\r\n//нажали на кнопку назад\r\nprev.addEventListener('click', ()=>{\r\n    //предусматриваем граничный вариант - когда дошли до первого -то следующим возврашаем слайдер в конечное, последее положение\r\n    //если offset равен 0, (причем мы сравниваем ==, а не присваиваем =)\r\n    // +width.slice(0, width.length - 2)  - плюс перед width меняет формат на числовой, а метод slice вырезает все нужное - с 0-вого элемента до длина width - 2 последних символа.\r\n    if(offset == 0){\r\n        //то в offset записываем последний слайд\r\n        offset = width * (slides.length -1);\r\n    }\r\n    //если слайд не первый - мы отнимаем ширину слайда\r\n    else{\r\n        offset -= width;\r\n    }\r\n\r\n    \r\n\r\n    caruselMove(offset); //смещаем карусель слайдов\r\n\r\n    //изменение индекса текущего слайда\r\n    if(slideIndex == 1){ //если мы на первом слайде - то иди в последний слайд\r\n        slideIndex = slides.length;\r\n    }\r\n    else{\r\n        slideIndex--; //или -1 слайд\r\n    }\r\n\r\n    currentSl(slides.length, current, slideIndex); // изменение текущего индикатора\r\n    dotActive(slideIndex); //выделение активной точки\r\n   \r\n});\r\n   \r\n//Перещелкивание слайдов при нажатии на точку\r\ndots.forEach(dot =>{\r\n    dot.addEventListener('click', (e) =>{\r\n        //будет получать атрибут 'data-slide-to', i+1) с уникальным номером\r\n        const slideTo = e.target.getAttribute('data-slide-to');\r\n        slideIndex = slideTo; //устанавливаем слайд индекс\r\n        offset = width * (slideTo -1); //устанавливаем смещение - по формуле но число берем = slideTo \r\n        /*** offset = +width.slice(0, width.length - 2) * (slideTo -1); //устанавливаем смещение - по формуле но число берем = slideTo offset = +width.slice(0, width.length - 2) * (slideTo -1); //устанавливаем смещение - по формуле но число берем = slideTo offset = +width.slice(0, width.length - 2) * (slideTo -1); //устанавливаем смещение - по формуле но число берем = slideTo offset = +width.slice(0, width.length - 2) * (slideTo -1); //устанавливаем смещение - по формуле но число берем = slideTo  \r\n        */\r\n        caruselMove(offset); //смещаем карусель слайдов\r\n      \r\n        currentSl(slides.length, current, slideIndex); // изменение текущего индикатора\r\n        dotActive(slideIndex); //выделение активной точки\r\n\r\n    })\r\n})\r\n\r\nfunction dotActive(ind){ //выделение активной точки\r\n    dots.forEach(dot => dot.style.opacity = '0.5'); //стили точкам - всем\r\n    dots[ind -1].style.opacity = '1';    //стиль активной точке\r\n};\r\n\r\nfunction caruselMove(moveStep){ //расчет сдвига карусели\r\n    slidesField.style.transform = `translateX(-${moveStep}px)`; //смещаем карусель слайдов\r\n}\r\n\r\nfunction currentSl(slLenght, cur, slIn){\r\n        // изменение текущего индикатора\r\n        if(slLenght < 10){\r\n            cur.textContent = `0${slIn}`; //с подставлением 0 для однозначного числа\r\n        }\r\n        else{\r\n            cur.textContent = slIn; //для двухзначного числа\r\n        }\r\n\r\n}\r\n       \r\n}\r\nmodule.exports = slider; ","﻿// ТАБЫ\r\nfunction tabs(){\r\n        //табы\r\n        const tabs = document.querySelectorAll('.tabheader__item'),\r\n        tabsContent = document.querySelectorAll('.tabcontent'),\r\n        tabsParent = document.querySelector('.tabheader');\r\n    function hideTabeContent(){\r\n        tabs.forEach(item=>{\r\n            item.classList.remove('tabheader__item_active');\r\n        })\r\n        tabsContent.forEach(item =>{\r\n            item.style.display = 'none';\r\n        });\r\n    }\r\n    function showTabContent(i = 0){\r\n        tabsContent[i].style.display = \"block\";\r\n        tabs[i].classList.add('tabheader__item_active')\r\n    }\r\n\r\n    hideTabeContent();\r\n    showTabContent();\r\n        \r\n    tabsParent.addEventListener('click', (event)=>{\r\n    const target = event.target;\r\n    if(target&&target.classList.contains('tabheader__item')){\r\n        tabs.forEach((item, i)=>{\r\n            if(target==item){\r\n                //console.log(item);\r\n                hideTabeContent();\r\n                showTabContent(i);\r\n            } \r\n        });\r\n    }\r\n    });\r\n}\r\n\r\nmodule.exports = tabs; ","﻿function timer(){\r\n// * * * * * * * * * * * * * * * * * \r\n//таймер\r\nconst deadline   = '06 30 2023'; //начальная точка - !месяц - день - год!, строку в таком формате часто возвращают инпуты\r\n//Функция, определяющая разницу между deadline и текущим временем\r\nconst tInM = Date.parse(deadline), //парсим строку \r\ntInUsualFormat =  new Date(tInM); //выводим из миллисек дату\r\n//console.log(tInUsualFormat); \r\n\r\nconst data = new Date();\r\n//console.log(data);\r\nfunction getTimeRemaining(endtime){\r\n    const t = Date.parse(endtime) - Date.parse(new Date()), //количество миллисекунд\r\n    days =  Math.floor(t / (1000 * 60 * 60 * 24)), // Math.floor - округление до целого числа, (1000 * 60 * 60 * 24) = количество суток\r\n    hours = Math.floor((t / 1000 / 60 / 60) % 24), // 1000*60*60) % 24 - высчитываем часы, обязательно остаток от деления - он покажет округленный часть суток - часы, которые поместим в таймере\r\n    minutes = Math.floor((t / 1000 / 60) % 60), // остаток от деления  показывает минуты\r\n    seconds = Math.floor((t / 1000) % 60); //остаток от деления  показывает секунды\r\n    \r\n//соберем данные в объект\r\n    return {\r\n        'total': t, \r\n        days, //равносильно  'days': days,\r\n        hours, //равносильно 'hours': hours,\r\n        minutes,  //равносильно  'minutes':minutes,\r\n        seconds   //равносильно  'seconds': seconds\r\n    };\r\n}\r\n\r\n//эта функция для исправления формата времени - чтоб всегда показывалось не 1 число а 2 - 0*\r\nfunction getZero(num){\r\n    if(num >= 0 && num < 10){\r\n        return `0${num}`; //тут уже не число а строка\r\n    }\r\n    else return num;\r\n}\r\n\r\n//установка таймера на страницу\r\nfunction setClock(selector, endtime){\r\n    const timer = document.querySelector(selector), // selector = классу .timer \r\n    days = timer.querySelector('#days'),\r\n    hours = timer.querySelector('#hours'),\r\n    minutes = timer.querySelector('#minutes'),\r\n    seconds= timer.querySelector('#seconds'),\r\n    //\r\n    timeInterval = setInterval(updateClock, 1000);\r\n// от мигания версти! - если таймер вверху страницы или пользовательобновит страницу это мигание видно.\r\n//исправить это можно вручную вызвав функцию обновления часов\r\nupdateClock();\r\nfunction updateClock(){\r\n    const t = getTimeRemaining(endtime);\r\n    days.innerHTML = getZero(t.days);\r\n    hours.innerHTML =  getZero(t.hours);\r\n    minutes.innerHTML =  getZero(t.minutes);\r\n    seconds.innerHTML =  getZero(t.seconds);\r\n        if(t.total <=0){\r\n            clearInterval(timeInterval);\r\n            days.innerHTML = ' -';\r\n            hours.innerHTML =  ' -';\r\n            minutes.innerHTML =  ' -';\r\n            seconds.innerHTML =  ' -';\r\n        }\r\n    }\r\n\r\n}\r\n\r\nsetClock('.timer', deadline);\r\n\r\n\r\n\r\n// end таймер\r\n}\r\nmodule.exports = timer;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","window.addEventListener('DOMContentLoaded', ()=>{\r\n    const   tabs = require('./modules/tabs'),\r\n            calc = require('./modules/calc'),\r\n            cards = require('./modules/cards'),\r\n            forms = require('./modules/forms'),\r\n            modal = require('./modules/modal'),\r\n            slider = require('./modules/slider'),\r\n            timer = require('./modules/timer');\r\n    tabs();\r\n    calc();\r\n    cards();\r\n    forms();\r\n    modal();\r\n    slider();\r\n    timer();\r\n    \r\n});\r\n\r\n\r\n\r\n"],"names":[],"sourceRoot":""}